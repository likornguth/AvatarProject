{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Color, Line, LineBasicMaterial, Matrix4, Mesh, MeshBasicMaterial, Object3D, Quaternion, SphereGeometry, Vector3 } from 'three';\nconst _q = new Quaternion();\nconst _targetPos = new Vector3();\nconst _targetVec = new Vector3();\nconst _effectorPos = new Vector3();\nconst _effectorVec = new Vector3();\nconst _linkPos = new Vector3();\nconst _invLinkQ = new Quaternion();\nconst _linkScale = new Vector3();\nconst _axis = new Vector3();\nconst _vector = new Vector3();\nconst _matrix = new Matrix4();\n\n/**\n * CCD Algorithm\n *  - https://sites.google.com/site/auraliusproject/ccd-algorithm\n *\n * // ik parameter example\n * //\n * // target, effector, index in links are bone index in skeleton.bones.\n * // the bones relation should be\n * // <-- parent                                  child -->\n * // links[ n ], links[ n - 1 ], ..., links[ 0 ], effector\n * iks = [ {\n *\ttarget: 1,\n *\teffector: 2,\n *\tlinks: [ { index: 5, limitation: new Vector3( 1, 0, 0 ) }, { index: 4, enabled: false }, { index : 3 } ],\n *\titeration: 10,\n *\tminAngle: 0.0,\n *\tmaxAngle: 1.0,\n * } ];\n */\n\nclass CCDIKSolver {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n  constructor(mesh, iks = []) {\n    this.mesh = mesh;\n    this.iks = iks;\n    this._valid();\n  }\n\n  /**\n   * Update all IK bones.\n   *\n   * @return {CCDIKSolver}\n   */\n  update() {\n    const iks = this.iks;\n    for (let i = 0, il = iks.length; i < il; i++) {\n      this.updateOne(iks[i]);\n    }\n    return this;\n  }\n\n  /**\n   * Update one IK bone\n   *\n   * @param {Object} ik parameter\n   * @return {CCDIKSolver}\n   */\n  updateOne(ik) {\n    const bones = this.mesh.skeleton.bones;\n\n    // for reference overhead reduction in loop\n    const math = Math;\n    const effector = bones[ik.effector];\n    const target = bones[ik.target];\n\n    // don't use getWorldPosition() here for the performance\n    // because it calls updateMatrixWorld( true ) inside.\n    _targetPos.setFromMatrixPosition(target.matrixWorld);\n    const links = ik.links;\n    const iteration = ik.iteration !== undefined ? ik.iteration : 1;\n    for (let i = 0; i < iteration; i++) {\n      let rotated = false;\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        const link = bones[links[j].index];\n\n        // skip this link and following links.\n        // this skip is used for MMD performance optimization.\n        if (links[j].enabled === false) break;\n        const limitation = links[j].limitation;\n        const rotationMin = links[j].rotationMin;\n        const rotationMax = links[j].rotationMax;\n\n        // don't use getWorldPosition/Quaternion() here for the performance\n        // because they call updateMatrixWorld( true ) inside.\n        link.matrixWorld.decompose(_linkPos, _invLinkQ, _linkScale);\n        _invLinkQ.invert();\n        _effectorPos.setFromMatrixPosition(effector.matrixWorld);\n\n        // work in link world\n        _effectorVec.subVectors(_effectorPos, _linkPos);\n        _effectorVec.applyQuaternion(_invLinkQ);\n        _effectorVec.normalize();\n        _targetVec.subVectors(_targetPos, _linkPos);\n        _targetVec.applyQuaternion(_invLinkQ);\n        _targetVec.normalize();\n        let angle = _targetVec.dot(_effectorVec);\n        if (angle > 1.0) {\n          angle = 1.0;\n        } else if (angle < -1.0) {\n          angle = -1.0;\n        }\n        angle = math.acos(angle);\n\n        // skip if changing angle is too small to prevent vibration of bone\n        if (angle < 1e-5) continue;\n        if (ik.minAngle !== undefined && angle < ik.minAngle) {\n          angle = ik.minAngle;\n        }\n        if (ik.maxAngle !== undefined && angle > ik.maxAngle) {\n          angle = ik.maxAngle;\n        }\n        _axis.crossVectors(_effectorVec, _targetVec);\n        _axis.normalize();\n        _q.setFromAxisAngle(_axis, angle);\n        link.quaternion.multiply(_q);\n\n        // TODO: re-consider the limitation specification\n        if (limitation !== undefined) {\n          let c = link.quaternion.w;\n          if (c > 1.0) c = 1.0;\n          const c2 = math.sqrt(1 - c * c);\n          link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);\n        }\n        if (rotationMin !== undefined) {\n          link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).max(rotationMin));\n        }\n        if (rotationMax !== undefined) {\n          link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).min(rotationMax));\n        }\n        link.updateMatrixWorld(true);\n        rotated = true;\n      }\n      if (!rotated) break;\n    }\n    return this;\n  }\n\n  /**\n   * Creates Helper\n   *\n   * @return {CCDIKHelper}\n   */\n  createHelper() {\n    return new CCDIKHelper(this.mesh, this.iks);\n  }\n\n  // private methods\n\n  _valid() {\n    const iks = this.iks;\n    const bones = this.mesh.skeleton.bones;\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i];\n      const effector = bones[ik.effector];\n      const links = ik.links;\n      let link0, link1;\n      link0 = effector;\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        link1 = bones[links[j].index];\n        if (link0.parent !== link1) {\n          console.warn('THREE.CCDIKSolver: bone ' + link0.name + ' is not the child of bone ' + link1.name);\n        }\n        link0 = link1;\n      }\n    }\n  }\n}\nfunction getPosition(bone, matrixWorldInv) {\n  return _vector.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);\n}\nfunction setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\n  const v = getPosition(bone, matrixWorldInv);\n  array[index * 3 + 0] = v.x;\n  array[index * 3 + 1] = v.y;\n  array[index * 3 + 2] = v.z;\n}\n\n/**\n * Visualize IK bones\n *\n * @param {SkinnedMesh} mesh\n * @param {Array<Object>} iks\n */\nclass CCDIKHelper extends Object3D {\n  constructor(mesh, iks = [], sphereSize = 0.25) {\n    super();\n    this.root = mesh;\n    this.iks = iks;\n    this.matrix.copy(mesh.matrixWorld);\n    this.matrixAutoUpdate = false;\n    this.sphereGeometry = new SphereGeometry(sphereSize, 16, 8);\n    this.targetSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0xff8888),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.effectorSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x88ff88),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.linkSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x8888ff),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this.lineMaterial = new LineBasicMaterial({\n      color: new Color(0xff0000),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    this._init();\n  }\n\n  /**\n   * Updates IK bones visualization.\n   */\n  updateMatrixWorld(force) {\n    const mesh = this.root;\n    if (this.visible) {\n      let offset = 0;\n      const iks = this.iks;\n      const bones = mesh.skeleton.bones;\n      _matrix.copy(mesh.matrixWorld).invert();\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i];\n        const targetBone = bones[ik.target];\n        const effectorBone = bones[ik.effector];\n        const targetMesh = this.children[offset++];\n        const effectorMesh = this.children[offset++];\n        targetMesh.position.copy(getPosition(targetBone, _matrix));\n        effectorMesh.position.copy(getPosition(effectorBone, _matrix));\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j];\n          const linkBone = bones[link.index];\n          const linkMesh = this.children[offset++];\n          linkMesh.position.copy(getPosition(linkBone, _matrix));\n        }\n        const line = this.children[offset++];\n        const array = line.geometry.attributes.position.array;\n        setPositionOfBoneToAttributeArray(array, 0, targetBone, _matrix);\n        setPositionOfBoneToAttributeArray(array, 1, effectorBone, _matrix);\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j];\n          const linkBone = bones[link.index];\n          setPositionOfBoneToAttributeArray(array, j + 2, linkBone, _matrix);\n        }\n        line.geometry.attributes.position.needsUpdate = true;\n      }\n    }\n    this.matrix.copy(mesh.matrixWorld);\n    super.updateMatrixWorld(force);\n  }\n\n  /**\n   * Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app.\n   */\n  dispose() {\n    this.sphereGeometry.dispose();\n    this.targetSphereMaterial.dispose();\n    this.effectorSphereMaterial.dispose();\n    this.linkSphereMaterial.dispose();\n    this.lineMaterial.dispose();\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.isLine) child.geometry.dispose();\n    }\n  }\n\n  // private method\n\n  _init() {\n    const scope = this;\n    const iks = this.iks;\n    function createLineGeometry(ik) {\n      const geometry = new BufferGeometry();\n      const vertices = new Float32Array((2 + ik.links.length) * 3);\n      geometry.setAttribute('position', new BufferAttribute(vertices, 3));\n      return geometry;\n    }\n    function createTargetMesh() {\n      return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);\n    }\n    function createEffectorMesh() {\n      return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);\n    }\n    function createLinkMesh() {\n      return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);\n    }\n    function createLine(ik) {\n      return new Line(createLineGeometry(ik), scope.lineMaterial);\n    }\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i];\n      this.add(createTargetMesh());\n      this.add(createEffectorMesh());\n      for (let j = 0, jl = ik.links.length; j < jl; j++) {\n        this.add(createLinkMesh());\n      }\n      this.add(createLine(ik));\n    }\n  }\n}\nexport { CCDIKSolver, CCDIKHelper };","map":{"version":3,"names":["BufferAttribute","BufferGeometry","Color","Line","LineBasicMaterial","Matrix4","Mesh","MeshBasicMaterial","Object3D","Quaternion","SphereGeometry","Vector3","_q","_targetPos","_targetVec","_effectorPos","_effectorVec","_linkPos","_invLinkQ","_linkScale","_axis","_vector","_matrix","CCDIKSolver","constructor","mesh","iks","_valid","update","i","il","length","updateOne","ik","bones","skeleton","math","Math","effector","target","setFromMatrixPosition","matrixWorld","links","iteration","undefined","rotated","j","jl","link","index","enabled","limitation","rotationMin","rotationMax","decompose","invert","subVectors","applyQuaternion","normalize","angle","dot","acos","minAngle","maxAngle","crossVectors","setFromAxisAngle","quaternion","multiply","c","w","c2","sqrt","set","x","y","z","rotation","setFromVector3","setFromEuler","max","min","updateMatrixWorld","createHelper","CCDIKHelper","link0","link1","parent","console","warn","name","getPosition","bone","matrixWorldInv","applyMatrix4","setPositionOfBoneToAttributeArray","array","v","sphereSize","root","matrix","copy","matrixAutoUpdate","sphereGeometry","targetSphereMaterial","color","depthTest","depthWrite","transparent","effectorSphereMaterial","linkSphereMaterial","lineMaterial","_init","force","visible","offset","targetBone","effectorBone","targetMesh","children","effectorMesh","position","linkBone","linkMesh","line","geometry","attributes","needsUpdate","dispose","child","isLine","scope","createLineGeometry","vertices","Float32Array","setAttribute","createTargetMesh","createEffectorMesh","createLinkMesh","createLine","add"],"sources":["/Users/lindsaykornguth/Projects/RPM_Project/AvatarProject/node_modules/three/examples/jsm/animation/CCDIKSolver.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tLine,\n\tLineBasicMaterial,\n\tMatrix4,\n\tMesh,\n\tMeshBasicMaterial,\n\tObject3D,\n\tQuaternion,\n\tSphereGeometry,\n\tVector3\n} from 'three';\n\nconst _q = new Quaternion();\nconst _targetPos = new Vector3();\nconst _targetVec = new Vector3();\nconst _effectorPos = new Vector3();\nconst _effectorVec = new Vector3();\nconst _linkPos = new Vector3();\nconst _invLinkQ = new Quaternion();\nconst _linkScale = new Vector3();\nconst _axis = new Vector3();\nconst _vector = new Vector3();\nconst _matrix = new Matrix4();\n\n\n/**\n * CCD Algorithm\n *  - https://sites.google.com/site/auraliusproject/ccd-algorithm\n *\n * // ik parameter example\n * //\n * // target, effector, index in links are bone index in skeleton.bones.\n * // the bones relation should be\n * // <-- parent                                  child -->\n * // links[ n ], links[ n - 1 ], ..., links[ 0 ], effector\n * iks = [ {\n *\ttarget: 1,\n *\teffector: 2,\n *\tlinks: [ { index: 5, limitation: new Vector3( 1, 0, 0 ) }, { index: 4, enabled: false }, { index : 3 } ],\n *\titeration: 10,\n *\tminAngle: 0.0,\n *\tmaxAngle: 1.0,\n * } ];\n */\n\nclass CCDIKSolver {\n\n\t/**\n\t * @param {THREE.SkinnedMesh} mesh\n\t * @param {Array<Object>} iks\n\t */\n\tconstructor( mesh, iks = [] ) {\n\n\t\tthis.mesh = mesh;\n\t\tthis.iks = iks;\n\n\t\tthis._valid();\n\n\t}\n\n\t/**\n\t * Update all IK bones.\n\t *\n\t * @return {CCDIKSolver}\n\t */\n\tupdate() {\n\n\t\tconst iks = this.iks;\n\n\t\tfor ( let i = 0, il = iks.length; i < il; i ++ ) {\n\n\t\t\tthis.updateOne( iks[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Update one IK bone\n\t *\n\t * @param {Object} ik parameter\n\t * @return {CCDIKSolver}\n\t */\n\tupdateOne( ik ) {\n\n\t\tconst bones = this.mesh.skeleton.bones;\n\n\t\t// for reference overhead reduction in loop\n\t\tconst math = Math;\n\n\t\tconst effector = bones[ ik.effector ];\n\t\tconst target = bones[ ik.target ];\n\n\t\t// don't use getWorldPosition() here for the performance\n\t\t// because it calls updateMatrixWorld( true ) inside.\n\t\t_targetPos.setFromMatrixPosition( target.matrixWorld );\n\n\t\tconst links = ik.links;\n\t\tconst iteration = ik.iteration !== undefined ? ik.iteration : 1;\n\n\t\tfor ( let i = 0; i < iteration; i ++ ) {\n\n\t\t\tlet rotated = false;\n\n\t\t\tfor ( let j = 0, jl = links.length; j < jl; j ++ ) {\n\n\t\t\t\tconst link = bones[ links[ j ].index ];\n\n\t\t\t\t// skip this link and following links.\n\t\t\t\t// this skip is used for MMD performance optimization.\n\t\t\t\tif ( links[ j ].enabled === false ) break;\n\n\t\t\t\tconst limitation = links[ j ].limitation;\n\t\t\t\tconst rotationMin = links[ j ].rotationMin;\n\t\t\t\tconst rotationMax = links[ j ].rotationMax;\n\n\t\t\t\t// don't use getWorldPosition/Quaternion() here for the performance\n\t\t\t\t// because they call updateMatrixWorld( true ) inside.\n\t\t\t\tlink.matrixWorld.decompose( _linkPos, _invLinkQ, _linkScale );\n\t\t\t\t_invLinkQ.invert();\n\t\t\t\t_effectorPos.setFromMatrixPosition( effector.matrixWorld );\n\n\t\t\t\t// work in link world\n\t\t\t\t_effectorVec.subVectors( _effectorPos, _linkPos );\n\t\t\t\t_effectorVec.applyQuaternion( _invLinkQ );\n\t\t\t\t_effectorVec.normalize();\n\n\t\t\t\t_targetVec.subVectors( _targetPos, _linkPos );\n\t\t\t\t_targetVec.applyQuaternion( _invLinkQ );\n\t\t\t\t_targetVec.normalize();\n\n\t\t\t\tlet angle = _targetVec.dot( _effectorVec );\n\n\t\t\t\tif ( angle > 1.0 ) {\n\n\t\t\t\t\tangle = 1.0;\n\n\t\t\t\t} else if ( angle < - 1.0 ) {\n\n\t\t\t\t\tangle = - 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tangle = math.acos( angle );\n\n\t\t\t\t// skip if changing angle is too small to prevent vibration of bone\n\t\t\t\tif ( angle < 1e-5 ) continue;\n\n\t\t\t\tif ( ik.minAngle !== undefined && angle < ik.minAngle ) {\n\n\t\t\t\t\tangle = ik.minAngle;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ik.maxAngle !== undefined && angle > ik.maxAngle ) {\n\n\t\t\t\t\tangle = ik.maxAngle;\n\n\t\t\t\t}\n\n\t\t\t\t_axis.crossVectors( _effectorVec, _targetVec );\n\t\t\t\t_axis.normalize();\n\n\t\t\t\t_q.setFromAxisAngle( _axis, angle );\n\t\t\t\tlink.quaternion.multiply( _q );\n\n\t\t\t\t// TODO: re-consider the limitation specification\n\t\t\t\tif ( limitation !== undefined ) {\n\n\t\t\t\t\tlet c = link.quaternion.w;\n\n\t\t\t\t\tif ( c > 1.0 ) c = 1.0;\n\n\t\t\t\t\tconst c2 = math.sqrt( 1 - c * c );\n\t\t\t\t\tlink.quaternion.set( limitation.x * c2,\n\t\t\t\t\t                     limitation.y * c2,\n\t\t\t\t\t                     limitation.z * c2,\n\t\t\t\t\t                     c );\n\n\t\t\t\t}\n\n\t\t\t\tif ( rotationMin !== undefined ) {\n\n\t\t\t\t\tlink.rotation.setFromVector3( _vector.setFromEuler( link.rotation ).max( rotationMin ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( rotationMax !== undefined ) {\n\n\t\t\t\t\tlink.rotation.setFromVector3( _vector.setFromEuler( link.rotation ).min( rotationMax ) );\n\n\t\t\t\t}\n\n\t\t\t\tlink.updateMatrixWorld( true );\n\n\t\t\t\trotated = true;\n\n\t\t\t}\n\n\t\t\tif ( ! rotated ) break;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Creates Helper\n\t *\n\t * @return {CCDIKHelper}\n\t */\n\tcreateHelper() {\n\n\t\treturn new CCDIKHelper( this.mesh, this.iks );\n\n\t}\n\n\t// private methods\n\n\t_valid() {\n\n\t\tconst iks = this.iks;\n\t\tconst bones = this.mesh.skeleton.bones;\n\n\t\tfor ( let i = 0, il = iks.length; i < il; i ++ ) {\n\n\t\t\tconst ik = iks[ i ];\n\t\t\tconst effector = bones[ ik.effector ];\n\t\t\tconst links = ik.links;\n\t\t\tlet link0, link1;\n\n\t\t\tlink0 = effector;\n\n\t\t\tfor ( let j = 0, jl = links.length; j < jl; j ++ ) {\n\n\t\t\t\tlink1 = bones[ links[ j ].index ];\n\n\t\t\t\tif ( link0.parent !== link1 ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.CCDIKSolver: bone ' + link0.name + ' is not the child of bone ' + link1.name );\n\n\t\t\t\t}\n\n\t\t\t\tlink0 = link1;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction getPosition( bone, matrixWorldInv ) {\n\n\treturn _vector\n\t\t.setFromMatrixPosition( bone.matrixWorld )\n\t\t.applyMatrix4( matrixWorldInv );\n\n}\n\nfunction setPositionOfBoneToAttributeArray( array, index, bone, matrixWorldInv ) {\n\n\tconst v = getPosition( bone, matrixWorldInv );\n\n\tarray[ index * 3 + 0 ] = v.x;\n\tarray[ index * 3 + 1 ] = v.y;\n\tarray[ index * 3 + 2 ] = v.z;\n\n}\n\n/**\n * Visualize IK bones\n *\n * @param {SkinnedMesh} mesh\n * @param {Array<Object>} iks\n */\nclass CCDIKHelper extends Object3D {\n\n\tconstructor( mesh, iks = [], sphereSize = 0.25 ) {\n\n\t\tsuper();\n\n\t\tthis.root = mesh;\n\t\tthis.iks = iks;\n\n\t\tthis.matrix.copy( mesh.matrixWorld );\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.sphereGeometry = new SphereGeometry( sphereSize, 16, 8 );\n\n\t\tthis.targetSphereMaterial = new MeshBasicMaterial( {\n\t\t\tcolor: new Color( 0xff8888 ),\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis.effectorSphereMaterial = new MeshBasicMaterial( {\n\t\t\tcolor: new Color( 0x88ff88 ),\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis.linkSphereMaterial = new MeshBasicMaterial( {\n\t\t\tcolor: new Color( 0x8888ff ),\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis.lineMaterial = new LineBasicMaterial( {\n\t\t\tcolor: new Color( 0xff0000 ),\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis._init();\n\n\t}\n\n\t/**\n\t * Updates IK bones visualization.\n\t */\n\tupdateMatrixWorld( force ) {\n\n\t\tconst mesh = this.root;\n\n\t\tif ( this.visible ) {\n\n\t\t\tlet offset = 0;\n\n\t\t\tconst iks = this.iks;\n\t\t\tconst bones = mesh.skeleton.bones;\n\n\t\t\t_matrix.copy( mesh.matrixWorld ).invert();\n\n\t\t\tfor ( let i = 0, il = iks.length; i < il; i ++ ) {\n\n\t\t\t\tconst ik = iks[ i ];\n\n\t\t\t\tconst targetBone = bones[ ik.target ];\n\t\t\t\tconst effectorBone = bones[ ik.effector ];\n\n\t\t\t\tconst targetMesh = this.children[ offset ++ ];\n\t\t\t\tconst effectorMesh = this.children[ offset ++ ];\n\n\t\t\t\ttargetMesh.position.copy( getPosition( targetBone, _matrix ) );\n\t\t\t\teffectorMesh.position.copy( getPosition( effectorBone, _matrix ) );\n\n\t\t\t\tfor ( let j = 0, jl = ik.links.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst link = ik.links[ j ];\n\t\t\t\t\tconst linkBone = bones[ link.index ];\n\n\t\t\t\t\tconst linkMesh = this.children[ offset ++ ];\n\n\t\t\t\t\tlinkMesh.position.copy( getPosition( linkBone, _matrix ) );\n\n\t\t\t\t}\n\n\t\t\t\tconst line = this.children[ offset ++ ];\n\t\t\t\tconst array = line.geometry.attributes.position.array;\n\n\t\t\t\tsetPositionOfBoneToAttributeArray( array, 0, targetBone, _matrix );\n\t\t\t\tsetPositionOfBoneToAttributeArray( array, 1, effectorBone, _matrix );\n\n\t\t\t\tfor ( let j = 0, jl = ik.links.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst link = ik.links[ j ];\n\t\t\t\t\tconst linkBone = bones[ link.index ];\n\t\t\t\t\tsetPositionOfBoneToAttributeArray( array, j + 2, linkBone, _matrix );\n\n\t\t\t\t}\n\n\t\t\t\tline.geometry.attributes.position.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.matrix.copy( mesh.matrixWorld );\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis.sphereGeometry.dispose();\n\n\t\tthis.targetSphereMaterial.dispose();\n\t\tthis.effectorSphereMaterial.dispose();\n\t\tthis.linkSphereMaterial.dispose();\n\t\tthis.lineMaterial.dispose();\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\tconst child = children[ i ];\n\n\t\t\tif ( child.isLine ) child.geometry.dispose();\n\n\t\t}\n\n\t}\n\n\t// private method\n\n\t_init() {\n\n\t\tconst scope = this;\n\t\tconst iks = this.iks;\n\n\t\tfunction createLineGeometry( ik ) {\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tconst vertices = new Float32Array( ( 2 + ik.links.length ) * 3 );\n\t\t\tgeometry.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction createTargetMesh() {\n\n\t\t\treturn new Mesh( scope.sphereGeometry, scope.targetSphereMaterial );\n\n\t\t}\n\n\t\tfunction createEffectorMesh() {\n\n\t\t\treturn new Mesh( scope.sphereGeometry, scope.effectorSphereMaterial );\n\n\t\t}\n\n\t\tfunction createLinkMesh() {\n\n\t\t\treturn new Mesh( scope.sphereGeometry, scope.linkSphereMaterial );\n\n\t\t}\n\n\t\tfunction createLine( ik ) {\n\n\t\t\treturn new Line( createLineGeometry( ik ), scope.lineMaterial );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = iks.length; i < il; i ++ ) {\n\n\t\t\tconst ik = iks[ i ];\n\n\t\t\tthis.add( createTargetMesh() );\n\t\t\tthis.add( createEffectorMesh() );\n\n\t\t\tfor ( let j = 0, jl = ik.links.length; j < jl; j ++ ) {\n\n\t\t\t\tthis.add( createLinkMesh() );\n\n\t\t\t}\n\n\t\t\tthis.add( createLine( ik ) );\n\n\t\t}\n\n\t}\n\n}\n\nexport { CCDIKSolver, CCDIKHelper };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}